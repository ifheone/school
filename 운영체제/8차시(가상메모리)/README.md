# 가상 메모리

- 큰 논리 주소 공간을 작은 실제 메모리로 사상하는 기법
- 작업의 크기가 메인 메모리의 사용가능 공간에 제한 받지 않고, 작업이 실행될 때 필요한 일부가 메모리에 적재됨
- 메모리의 효율적 이용이 가능하며, 다중 프로그래밍의 정도를 증가시켜 프로세스의 이용률을 증가시킴

# 가상 메모리 관리 기법

- 세그먼트 기법과 페이징 기법의 혼합으로 외부 단편화 제거 및 내부 단편화 최소화
- 프로세서 하드웨어 비용이 증가하고 페이지 인터럽트 처리 시간이 증대되며 스레싱 방지를 위한 소프트웨어 복잡도가 커짐
- 프로그래머는 메모리를 이용하는 데 신경 쓰지 않음

# 요구 페이징

- 가장 일반적인 가상 메모리 체계로 수왑 기법을 사용하는 페이징 시스템과 비슷함
- 프로그램을 실행하기 위해 프로그램의 일부만을 메인 메모리에 적재
- 순차적으로 작성되어 있는 프로그램의 일부(모듈)가 처리될 때 다른 부분은 실행되지 않는다는 사실을 이용함

# 페이지 테이블

- 변화를 반영하기 위해 갱신되고 페이지 부재를 일으킨 명령은 다시 시작됨
  > 전체 기억장치의 내용이 동시에 주기억장치에 있지 않아도 프로세스를 수행할 수 있어 더 많은 프로세스 수행이 가능함
- 다중 프로그램의 정도와 시스템의 중앙처리장치 이용률 증가
- 프로세스의 기억장치 요구량이 이용할 수 있는 실제 메모리보다 클 때도 수행 가능

# 선입선출 대치 알고리즘(FIFO)

- 가장 간단한 페이지 대치 알고리즘
- 각 페이지가 메모리 안으로 들어간 시간을 이용, 가장 오래된 페이지부터 대치시킴
- 프로그래밍은 쉬우나 벨레디의 변이 현상으로 인한 문제 발생

# 최적 페이지 대치 알고리즘

- 모든 알고리즘 가운데 페이지 부재율이 가장 낮음
- '앞으로 가장 오랜 기간 동안 사용되지 않을 페이지를 대치하라'는 사상 표현
- 고정된 프레임 수에 대해 가능한 가장 낮은 페이지 부재율을 보장
- 참조 문자열이 언제 사용될 것인가에 대한 정확한 정보를 요구
  > 이는 알기 어려우므로 현실적인 구현이 어려움

# 최근 최소사용 알고리즘

- 가까운 미래의 근사치로써, 가장 최근의 과거를 사용하여 오랜 기간 동안 사용되지 않은 페이지를 대치하는 알고리즘
- 최적의 근사치이나 구현이 어려움
- 이의 근사치 알고리즘으로 시계(이차적 기회 페이지 대치) 알고리즘이 제안됨
